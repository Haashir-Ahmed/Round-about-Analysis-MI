# ROUNDABOUTS, HUMAN ERROR CRASHES, & INCOME COMPARISON

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

plt.rcParams["figure.dpi"] = 120
sns.set_style("whitegrid")

# 1. LOAD DATA

# Upload both CSVs to Colab before running
sim = pd.read_csv("/Similiarintersections.csv")
rnd = pd.read_csv("/Roundabouts.csv")

sim["Intersection_Type"] = "Non-Roundabout"
rnd["Intersection_Type"] = "Roundabout"
sim = sim[sim["Median_HH_Income"].notna() & (sim["Median_HH_Income"] > 0)]
rnd = rnd[rnd["Median_HH_Income"].notna() & (rnd["Median_HH_Income"] > 0)]

df = pd.concat([sim, rnd], ignore_index=True)

# 2. DEFINE HUMAN-ERROR CRASH VARIABLES

human_error_vars = [
    "rate_NO_FACTOR",
    "rate_DISTRACTED",
    "rate_DRUG",
    "rate_ALCOHOL",
    "rate_SPEEDING",
    "rate_HITNRUN",
    "rate_KCOUNT",
    "rate_TOTAL_CRASHES"
]

# Keep only columns that exist
human_error_vars = [v for v in human_error_vars if v in df.columns]

# 3. DEFINE INCOME GROUPS
# Bottom 25% = Low income
# Top 25% = High income
low_thresh = df["Median_HH_Income"].quantile(0.25)
high_thresh = df["Median_HH_Income"].quantile(0.75)

def income_group(x):
    if x <= low_thresh:
        return "Low Income"
    elif x >= high_thresh:
        return "High Income"
    else:
        return "Middle Income"

df["Income_Group"] = df["Median_HH_Income"].apply(income_group)

# Keep only low and high income for clean comparison
df_lh = df[df["Income_Group"].isin(["Low Income", "High Income"])]


# 4. MEAN COMPARISON TABLE
# 5. BAR PLOTS: ROUNDABOUT VS NON-ROUNDABOUT
#    SEPARATED BY INCOME GROUP

for var in human_error_vars:
    plt.figure()
    sns.barplot(
        data=df_lh,
        x="Income_Group",
        y=var,
        hue="Intersection_Type",
        errorbar=None # Updated from ci=None
    )
    plt.title(f"{var}: Roundabout vs Non-Roundabout by Income Level")
    plt.ylabel("Crash Rate (Exposure-Adjusted)")
    plt.xlabel("")
    plt.legend(title="")
    plt.ylim(0, df_lh[var].max() * 1.1) # Set y-axis to start at 0 and go slightly above max
    plt.gca().yaxis.set_major_locator(plt.MaxNLocator(nbins=5)) # Adjust increments
    plt.show()
